###走进并行世界
----
####摩尔定律

摩尔定律是由英特尔创始人之一戈登.摩尔提出来的，其内容为：集成电路可容纳的
电晶体（晶体管）数目，约每隔24月便会增加一倍；经常被引用的"18个月"，是由
英特尔首席执行官大卫.豪斯所说：预计18个月会将芯片的性能提高一倍（即更多的
晶体管使其更快）

**说得直白点，就是每18个月到24个月，我们计算机的性能就能翻一番。** 

**反过来说，就是每过18-24个月，你在未来用一半的价钱就能买到和现在的性能
相同的计算设备了。**

**后后摩尔定律被推翻，制造工艺已经到纳米了，无法在物质分子层面以下进行工作。**

**顶级计算机科学家唐纳德.尔文.克努斯，如此评价这种情况：这种现象（并发）或多
或少由于硬件设计者已经无计可施了导致的，他们将摩尔定律失效的责任推脱给软件开发者**

后来硬件工程师想出来将多个cpu内核塞进一个cpu的奇妙想法。由此，并行计算被推广而来
而随之而来的问题也层出不穷，程序员的黑暗由此而来，

**唐纳德："他们将摩尔定律失效的责任推脱给了软件开发者"的说法。**

**所以，如何让多个cpu有效并且正确地工作也就成了一门技术，甚至是很大的学问。
比如：多线程间如何保证线程安全，如何正确理解线程间的可见性和无序性，如何尽可能
提高并行程序的设计，又如何将串行程序改造为并行程序。**

----
####同步和异步
同步和异步通常用来形容一次方法调用。

**同步方法调用一旦开始，调用者必须等到方法调用返回后，才能继续后续的行为。**

**异步方法更像是一个消息传递，一旦开始，方法调用就会立即返回，调用者
就可以继续做后续的操作。而异步方法通常会在另外一个线程中"真实"的执行。
整个过程，不会阻塞调用者的工作。
----
####并发和并行
并发：
**偏重于多个任务交替执行，而多个任务之间有可能是串行的。从严格意义上来讲，
并发的过程是交替的，一会运行任务a，一会运行任务b，系统会不停地在两者间切换。**

并行：
**是真正意义上的同时执行**

----
####临界区
**临界区用来表示一种公共资源或者是共享数据，可以被多个线程使用。但是每一次，
只能有一个线程使用它，一点临界区资源被占用，其他线程要想使用这个资源，就必须等待。**

**比如，在一个办公室里有一台打印机，打印机只能执行一个任务，两个用户需要打印，谁先下发
任务，先执行谁的，另一用户会阻塞在那里，只能一个用户打印完成之后，另一个用户才可以执行。
这里所说的打印机就是临界区的概念。**

在并行程序中，临界区资源是保护的对象，如果意外出现打印机同时执行两个打印任务，那么最可能
的结果就是打印出来的文件就会是损坏的文件。都不是两个用户想要的。
---
####阻塞（Blocking）和非阻塞（Non-Blocking）
阻塞和非阻塞通常用来形容多线程间的相互影响。比如一个线程占用了临界区资源，那么其他
所有需要这个资源的线程就必须在这个临界区中进行等待。等待会导致线程挂起，从用户态-》
内核态，这就是阻塞。此时，如果占用资源的线程一直不愿意释放资源，那么阻塞在这个临界区上
的所有线程都不能工作。

**非阻塞的意思与之相反，它强调没有一个线程可以妨碍另外一个线程执行。所有的线程都会尝试
不断向前执行。
---
###死锁 饥饿 活锁
都属于多线程的活跃性问题。

----
###存在的问题
原子性

可见性

有序性（指令重排）

---
####哪些指令不能重排：Happen-Before规则
- 程序顺序原则：一个线程内保证语义的串行性
- volatile：变量的写，先发生于读，这保证了volatile变量的可见性。
- 锁规则：unlock操作必然发生在后续的对同一个的锁的lock之前。也就是说
如果对一个解锁后再加锁，那么加锁动作绝对不会重排到解锁动作之前。很显然
，如果这么做，加锁行为是无法获得这把锁的。

- 传递性：a先于b，b先于c，那么a必然先于c
-  线程的start（）方法先于它的每一个动作
- 线程的所有操作先于线程的终结（Thread.join(）)
- 线程的中断（interrupt（））先于被中断线程的代码
- 对象的构造函数执行、结束先于finalize（）方法

原则是为了保证指令重排不会破坏原有的语义结构。




