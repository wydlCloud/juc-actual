####锁
--------------
”锁“是最常用的同步方法之一。在高并发的环境下，激烈的锁竞争会导致程序的性能下降。所以我们自然有必要讨论一些有关"锁”的性能问题
以及相关一些注意事项。
- 避免死锁
- 减小锁粒度
- 锁分离等


**在多核时代，使用多线程可以明显地提高系统的性能。但事实上，使用多线程的方式会额外增加系统的开销。**


**对于单任务或者多线程的应用而言，其主要资源消耗都花在任务本身，它既不需要维护并行数据结构间的一致性状态，
也不需要为线程的切换和调度花费时间。但是对于多线程应用来说，系统除了处理功能需求外，还需要额外维护多线程环形的特有信息，
如线程本身的元数据、线程的调度、线程上下文的切换等。**

**事实上，在单核CPU上，采用并行算法的效率一般要低于原始的串行算法的，其根本原因也在于此。因此，并行计算之所以能提高系统的性能，
并不是因为它少干活了，而是因为并行计算可以更加合理地进行任务调度，充分利用各个cpu资源。因此，合理的并发，才能将多核cpu的性能发挥到极致**

------------------
###有助于提高“锁”性能的几点建议
“锁“的竞争必然会导致程序的整体性能下降。为了将这种副作用降到最低，关于使用锁的一些建议。

- 1.减小锁持有时间

**对于使用锁进行并发控制的应用程序而言，在锁竞争过程中，单个线程对锁的持有时间与系统性能有着直接的关系。如果线程持有锁的
时间很长，那么相对地，锁的竞争也就越激烈。要尽可能地减少对某个锁的占有时间，以减少线程间互斥的可能。
减少锁的持有时间有助于降低锁冲突的可能性，进而提升系统的并发能力。具体要根据业务场景来决定如何去处理**

- 2.减小锁粒度

**减小锁粒度也是一种削弱多线程竞争的有效手段。这种技术典型的使用场景就是ConcurrentHashMap类的实现。
所谓减少锁粒度，就是指缩小锁定对象的范围，从而减少锁冲突的可能性，进而提高系统的并发能力。**

- 3.读写分离锁来替换独占锁

**在读多写少的场合，使用读写锁可以有效提升系统的并发能力。**

- 4.锁分离

**LinkedBlockingQueue得到了很好的体现，可以大大的减少锁竞争**
- 5.锁粗化

**通常情况下，为了保证多线程间的有效并发，会要求每个线程持有锁的时间尽量短，即在使用完公共资源后，应该立即释放锁。只有这样等待在
这个锁上的其他线程才能尽早的获得资源执行任务。但是凡事都有一个度，如果对同一个锁不停地进行请求、同步和释放，其本身也会消耗系统宝贵
的资源，反而不利于性能的优化。
为此，虚拟机在遇到一连串连续地对同一锁进行请求和释放的操作时，便会把所有的锁操作整合成对锁的一次请求，从而减少对锁的请求同步次数，
这个操作叫做锁的粗化。**

-----
**性能优化就是根据运行时的真实情况对各个资源点进行权衡折中的过程。锁粗化的思想和减少锁持有时间是相反的，但在不同的场合，效果不尽相同。
所以如何使用还要根据具体的业务场景来使用。**

------
###java虚拟机对锁优化所做的努力

作为一款公用平台，jdk本身也为并发程序的性能绞尽脑汁。
在jdk内部也想尽一切办法提供并发时的系统吞吐量。下面了解一下
jdk内部的"锁"优化策略。

- 锁偏向

**锁偏向是一种针对加锁操作的优化手段。它的核心思想是：如果一个线程获取了锁，那么
锁就进入偏向模式。当这个线程再次请求锁时，无须再做任何同步操作。这样就节省了大量
有关锁申请的操作，从而提高了程序性能。因此，对于几乎没有锁竞争的场合，偏向锁有比较好的
优化效果，因为连续多次极有可能是同一个线程请求相同的锁。而对于锁竞争比较激烈的场合，其效果不佳。
因为竞争激烈的场合，最有可能的情况是每次都是不同的线程来请求相同的锁，这样偏向模式
就会失效，因此还不如不启用偏向锁。使用java虚拟机参数：
-xx：+UseBiasedLocking可以开启偏向锁。**

- 轻量级锁

**如果偏向锁失效，虚拟机并不会立即挂起线程。它还会使用一种称为轻量级锁的优化手段。
轻量级锁的操作也很轻便，它只是简单地将对象头部作为指针，指向持有锁的线程堆栈的内部，
来判断一个线程是否持有对象锁。如果线程获得了轻量级锁成功，则可以顺利进入临界区。
如果轻量级锁加锁失败，则表示其他线程抢先争夺到了锁，那么当前线程的锁请求就会膨胀为
重量级锁。
