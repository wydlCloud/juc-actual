####锁
--------------
”锁“是最常用的同步方法之一。在高并发的环境下，激烈的锁竞争会导致程序的性能下降。所以我们自然有必要讨论一些有关"锁”的性能问题
以及相关一些注意事项。
- 避免死锁
- 减小锁粒度
- 锁分离等


**在多核时代，使用多线程可以明显地提高系统的性能。但事实上，使用多线程的方式会额外增加系统的开销。**


**对于单任务或者多线程的应用而言，其主要资源消耗都花在任务本身，它既不需要维护并行数据结构间的一致性状态，
也不需要为线程的切换和调度花费时间。但是对于多线程应用来说，系统除了处理功能需求外，还需要额外维护多线程环形的特有信息，
如线程本身的元数据、线程的调度、线程上下文的切换等。**

**事实上，在单核CPU上，采用并行算法的效率一般要低于原始的串行算法的，其根本原因也在于此。因此，并行计算之所以能提高系统的性能，
并不是因为它少干活了，而是因为并行计算可以更加合理地进行任务调度，充分利用各个cpu资源。因此，合理的并发，才能将多核cpu的性能发挥到极致**

------------------
###有助于提高“锁”性能的几点建议
“锁“的竞争必然会导致程序的整体性能下降。为了将这种副作用降到最低，关于使用锁的一些建议。

- 1.减小锁持有时间

**对于使用锁进行并发控制的应用程序而言，在锁竞争过程中，单个线程对锁的持有时间与系统性能有着直接的关系。如果线程持有锁的
时间很长，那么相对地，锁的竞争也就越激烈。要尽可能地减少对某个锁的占有时间，以减少线程间互斥的可能。
减少锁的持有时间有助于降低锁冲突的可能性，进而提升系统的并发能力。具体要根据业务场景来决定如何去处理**

- 2.减小锁粒度

**减小锁粒度也是一种削弱多线程竞争的有效手段。这种技术典型的使用场景就是ConcurrentHashMap类的实现。
所谓减少锁粒度，就是指缩小锁定对象的范围，从而减少锁冲突的可能性，进而提高系统的并发能力。**

- 3.读写分离锁来替换独占锁

**在读多写少的场合，使用读写锁可以有效提升系统的并发能力。**

- 4.锁分离

**LinkedBlockingQueue得到了很好的体现，可以大大的减少锁竞争**
- 5.锁粗化

**通常情况下，为了保证多线程间的有效并发，会要求每个线程持有锁的时间尽量短，即在使用完公共资源后，应该立即释放锁。只有这样等待在
这个锁上的其他线程才能尽早的获得资源执行任务。但是凡事都有一个度，如果对同一个锁不停地进行请求、同步和释放，其本身也会消耗系统宝贵
的资源，反而不利于性能的优化。
为此，虚拟机在遇到一连串连续地对同一锁进行请求和释放的操作时，便会把所有的锁操作整合成对锁的一次请求，从而减少对锁的请求同步次数，
这个操作叫做锁的粗化。**

-----
**性能优化就是根据运行时的真实情况对各个资源点进行权衡折中的过程。锁粗化的思想和减少锁持有时间是相反的，但在不同的场合，效果不尽相同。
所以如何使用还要根据具体的业务场景来使用。**
