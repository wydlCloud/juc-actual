####线程复用：线程池
-
多线程的软件设计方法确实可以最大限度地发挥现代多核处理器的计算能力，提高生产系统的吞吐量和性能。
但是，若不加控制和管理的随意使用线程，对系统的性能反而会产生不利的影响。
一种最为简单的线程创建和回收的方法类似如下代码所示：
  
new Thread(()->{
@Override
public void run(){
}
}).start();

以上代码创建了一个线程，并在run()方法结束后，自动回收该线程。在简单的应用系统中，这段代码并没有太多
问题。但是在真实的生产环境中，系统由于真实环境的需要，可能会开启很多线程来支撑其应用。而当现场数量过大时，
反而会耗尽cpu和内存资源。

--------------------------------------------------------------
首先：虽然与进程相比，线程是一种轻量级的工具，但其创建和关闭依然需要花费时间，如果为每一个小的任务都创建一个线程
很有可能出现创建和销毁线程所占用的时间大于该线程真实工作所消耗的情况，反而会得不偿失。

其次，线程本身也是占用内存空间的，大量的线程会抢占宝贵的内存资源，如果处理不当，可能会导致om异常、
即便没有，大量的线程回收也会给GC带来很大的压力，延长GC的停顿时间。
因此，对线程的使用必须掌握一个度，在有限的范围内，增加线程的数量可以明显提高系统的吞吐量，但一旦超出了这个范围，
大量的线程只会拖垮应用系统。因此，在生产环境中使用线程，必须对其控制和管理。

总结：在实际的工作过程中，必须要控制线程的创建和销毁，以及线程的数量加以控制。

--------------------------------------------------
什么是线程池？
为了避免系统频繁地创建和销毁线程，我们可以让创建的线程进行复用。如果大家进行过数据库开发，对数据库连接不会陌生。
为了避免每次查出数据库都重新建立和销毁数据库连接，我们可以使用数据库连接池维护一些数据库连接，让他们长期保持在一个
激活状态。当系统需要使用使用数据库的时候，并不是创建一个新的连接，而是从连接池中获得一个可用的连接即可。
反之，当需要关闭连接时，并不是真的把连接关闭，而是将这个连接“还"给连接池即可。
通过这种方式，可以节约不少创建和销毁对象的时间。
线程池也是类似的概念。线程池中，总有那么几个活跃线程。当你需要使用线程时，可以从池子中随便拿一个
空闲线程，当完成工作时，并不着急关闭线程，而是将这个线程退回到池子，方便其他人使用。

简而言之，在使用线程池后，创建线程变成了从线程池获得空闲线程，关闭线程变成了向池子归还线程。
-------------
线程池的设计：

设计模式：是主要使用的是工厂模式来实现的。
工厂方法分别返回不同工作特性的线程池，
这些线程池工厂方法的具体说明如下：

- newFixedThreadPool()方法：该方法返回一个固定线程数量的线程池。该线程吃中的线程数量始终不变。
当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有则新的任务会被暂存在一个任务队列中，
待有线程空闲时，便处理在任务队列中的任务。


- newSingleThreadExecutor()方法：该方法返回一个只有一个线程的线程池。若多余一个任务被提交到线程池，
任务会被保存在一个任务队列中，待线程空闲，按照先入先出的顺序执行队列中的任务。
- newCachedThreadPool()方法：该方法返回一个可根据实际情况调整线程数量的线程池。线程池的线程数量不确定，
但若有空闲线程可以复用，则会有限使用可复用的线程，若所有线程均在工作，又有新的任务提交，则会创建新的
线程处理任务。所有线程在当前任务执行完毕后，将返回线程池进行复用。

- newSingleThreadScheduleExecutor()方法：该方法返回一个ScheduledExecutorService对象，线程池大小为1，
。ScheduledExecutorService接口在ExecutorService接口之上扩展了在给定时间执行某任务的功能，如在某个固定的
延期之后执行，或者周期性执行某个任务。
- newScheduledThreadPool()方法：该方法也返回一个ScheduleExecutorService对象，但该线程池可以指定线程数量。
-------------------------------------------------

JDK内置的拒绝策略如下：
- AbortPolicy策略：该策略只会直接抛出异常，阻止系统正常工作。
- CallerRunsPolicy策略:只要线程池未关闭，该策略直接再调用者线程中，运行当前被丢弃的任务。显然这样做不会真的弄丢任务，但是
在任务提交线程的性能极有可能会急剧下降。
- DiscardOledestPolicy：该策略将丢弃最老的一个请求，也就是即将被执行的一个任务，并尝试再次提交当前任务。
- DiscardPolicy：该策略默默地丢弃无法处理的任务，不予任何处理。

以上内置的策略均扩展实现了RejectedExecutionHandler接口，若以上策略扔无法满足实际应用需要，完全可以自己扩展RejectExecutionHandle
接口。